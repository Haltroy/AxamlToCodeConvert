/*
 * Copyright (C) 2022 haltroy
 *
 * Use of this source code is governed by MIT License that can be found in
 * https://github.com/haltroy/AxamlToCodeConvert/blob/main/LICENSE
 *
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;

namespace AxamlToCodeConvert
{
    public static class Converter
    {
        public static string Convert(string xml)
        {
            if (string.IsNullOrWhiteSpace(xml)) { return xml; }
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xml);

            var windowNode = doc.DocumentElement;

            string csharpcode = "// Auto-Generated by AxamlToCodeConverter"
                + Environment.NewLine
                + "// https://github.com/haltroy/AxamlToCodeConvert"
                + Environment.NewLine
                + "// Add this code to your window class."
                + Environment.NewLine
                + "// NOTE: This stuff is not perfect, you might have to manually edit it."
                + Environment.NewLine
                + "// Also, change the 'AvaloniaXamlLoader.Load(this); with Init();"
                + Environment.NewLine
                + Environment.NewLine
                + "#region Init"
                + Environment.NewLine
                + "private void Init()"
                + Environment.NewLine
                + "{"
                + Environment.NewLine;

            List<(string name, string type)> definedNames = new List<(string name, string type)>();

            string ignored = ""; // ignored

            csharpcode += NodeAttrToCode(windowNode, definedNames, out ignored);
            csharpcode += NodeChildsToCode(windowNode, "this", definedNames);

            csharpcode += "}" + Environment.NewLine + Environment.NewLine;

            for (int i = 0; i < definedNames.Count; i++)
            {
                var name = definedNames[i];
                csharpcode += name.type + "? " + name.name + ";" + Environment.NewLine;
            }

            csharpcode += Environment.NewLine + "#endregion Init" + Environment.NewLine;

            return csharpcode;
        }

        private static string NodeChildsToCode(XmlNode node, string nodeName, List<(string name, string type)> definedNames)
        {
            if (node.OuterXml.StartsWith("<!--")) { return ""; }
            string childs = "";
            for (int i = 0; i < node.ChildNodes.Count; i++)
            {
                var child = node.ChildNodes[i];
                string childName = "";
                childs += NodeAttrToCode(child, definedNames, out childName);
                childs += "    " + nodeName + ".Children.Add(" + childName + ");" + Environment.NewLine + Environment.NewLine;

                childs += NodeChildsToCode(child, childName, definedNames);
            }
            return childs;
        }

        private static string GenerateNodeName(XmlNode node, List<(string name, string type)> definedNames)
        {
            if (node.Attributes != null && node.Attributes["Name"] is XmlAttribute attr)
            {
                definedNames.Add((attr.InnerXml, node.Name));
                return attr.Value;
            }
            else
            {
                for (int i = 0; i < int.MaxValue; i++)
                {
                    string newName = FirstCharToLowerCaseInvariant(node.Name + i);
                    if (definedNames.FindAll(it => it.name == newName).Count <= 0)
                    {
                        definedNames.Add((newName, node.Name));
                        return newName;
                    }
                }
                return GenerateRandomText();
            }
        }

        private static string? FirstCharToLowerCaseInvariant(this string? str)
        {
            if (!string.IsNullOrEmpty(str) && char.IsUpper(str[0]))
                return str.Length == 1 ? char.ToLowerInvariant(str[0]).ToString() : char.ToLowerInvariant(str[0]) + str[1..];

            return str;
        }

        private static string GenerateRandomText(int length = 17)
        {
            if (length == 0) { throw new ArgumentOutOfRangeException("\"length\" must be greater than 0."); }
            if (length < 0) { length = length * -1; }
            if (length >= int.MaxValue) { throw new ArgumentOutOfRangeException("\"length\" must be smaller than the 32-bit integer limit."); }
            StringBuilder builder = new StringBuilder();
            Enumerable
               .Range(65, 26)
                .Select(e => ((char)e).ToString())
                .Concat(Enumerable.Range(97, 26).Select(e => ((char)e).ToString()))
                .Concat(Enumerable.Range(0, length - 1).Select(e => e.ToString()))
                .OrderBy(e => Guid.NewGuid())
                .Take(length)
                .ToList().ForEach(e => builder.Append(e));
            return builder.ToString();
        }

        private static string NodeAttrToCode(XmlNode node, List<(string name, string type)> definedNames, out string nodeName)
        {
            if (node.OuterXml.StartsWith("<!--")) { nodeName = ""; return ""; }
            nodeName = GenerateNodeName(node, definedNames);
            string attributes = $"    {nodeName} = new {node.Name.Replace(":", ".")}();{Environment.NewLine}";
            for (int i = 0; i < node.Attributes.Count; i++)
            {
                // Super basic conversion, need to improve so it also detects enums, margin, IImage etc.
                XmlNode attr = node.Attributes[i];
                attributes += $"    {nodeName}.{attr.Name} = \"{attr.InnerText}\";" + Environment.NewLine;
            }
            return attributes;
        }
    }
}